---
title: "Processing GBM/HGG tumor Xenium data"
author: "heinin"
date: "2025-10-10"
output:
  workflowr::wflow_html:
    code_folding: hide
  html_notebook: default
editor_options:
  chunk_output_type: console
---

### Packages and environment variables

```{r, warning=F, message=F}

suppressPackageStartupMessages({
  library(workflowr)
  library(arrow)
  library(Seurat)
  library(SeuratObject)
  library(SeuratDisk)
  library(tidyverse)
  library(tibble)
  library(ggplot2)
  library(ggpubr)
  library(ggrepel)
  library(workflowr)})

```

### Environment variables and helper functions

```{r, message = F, warning = F}

setwd("/home/hnatri/13384_GBMHGG_SPP1_Xenium/")
set.seed(9999)
options(scipen = 99999)
options(ggrepel.max.overlaps = Inf)

# Colors, themes, and cell type markers
#source("/home/hnatri/13384_GBMHGG_SPP1_Xenium/code/colors_themes.R")

# A simplified VlnPlot
BetterVlnPlot <- function(data, features, group_by, ylim = NA){
  VlnPlot(data, pt.size = 0, features = features, 
          group.by = group_by, y.max = ylim) + labs(x = "") + NoLegend()
}

# DimPlots of before and after for each sample
DimPlotCompare <- function(tma){
  bf_cells <- ncol(subset(spatial_unfiltered, subset = TMA == tma))
  a <- DimPlot(subset(spatial_unfiltered, subset = TMA == tma),
               reduction = "sp") + NoLegend() +
    labs(title = paste0(tma, ", Unfiltered, ", bf_cells, " nuclei"))
  
  aft_cells <- ncol(subset(spatial_filtered, subset = TMA == tma))
  b <- DimPlot(subset(spatial_filtered, subset = TMA == tma),
               reduction = "sp") + NoLegend() +
    labs(title = paste0(tma, ", Filtered, ", aft_cells, " nuclei"))
  ggarrange(a,b)
}

```

### Import data

```{r, message = F, warning = F, eval = F}

data_dir <- "/tgen_labs/banovich/xenium_run_folders/20251003__191226__COMBO_NB-TGenTMA_CB-hBrainTMA1"
tma_list <- c(
  TMA1_0069295 = "output-XETG00048__0069295__NB_TGenTMA1__20251003__191241",
  TMA1_0069754 = "output-XETG00048__0069754__CB_hBrainTMA1__20251003__191242")

# Get subdirectory names for obtaining file paths
subdirs <- unname(tma_list)

# Get transcript counts and metadata
all_files <- list.files(file.path(data_dir, subdirs), full.names = TRUE)
h5_files <- all_files[grep(".h5", all_files)]
transcript_files <- all_files[grep("transcripts.parquet", all_files)]
meta_files <- all_files[grep("cells.csv.gz", all_files)]

# Read in files
counts <- lapply(h5_files, Read10X_h5)

transcripts <- lapply(transcript_files, function(XX) {
  read_parquet(XX) })

metadata <- lapply(meta_files, function(XX) {
  tmp_meta <- read.delim(XX, sep = ",", colClasses = c(cell_id = "character"))
  rownames(tmp_meta) <- tmp_meta$cell_id
  tmp_meta })

# Rename files in lists
tma_ids <- names(tma_list)
names(counts) <- tma_ids
names(transcripts) <- tma_ids
names(metadata) <- tma_ids

```

### Get all transcripts, create cell x gene matrix, and count the number of blanks per cell

```{r, message = F, warning = F, eval = F}

all_transcripts <- list()
nuc_transcripts <- list()
updated_metadata <- list()
nuc_updated_metadata <- list()
for (tma in tma_ids) {
  message(paste("Getting cell counts for TMA ", tma))
  
  # Filter out low quality transcripts 
  all_transcripts[[tma]] <- transcripts[[tma]][transcripts[[tma]]$qv > 20, ]
  
  # Find transcripts that overlap a nucleus
  #nuc_transcripts[[tma]] <- transcripts[[tma]][transcripts[[tma]]$overlaps_nucleus == "1", ]
  
  # Create cell x gene dataframe
  all_transcripts[[tma]] <- as.data.frame(table(all_transcripts[[tma]]$cell_id, 
                                               all_transcripts[[tma]]$feature_name))
  names(all_transcripts[[tma]]) <- c("cell_id", "feature_name", "Count")
  all_transcripts[[tma]] <- all_transcripts[[tma]] %>% 
    pivot_wider(names_from = "feature_name", values_from = "Count")
  
  # Get blanks count per cell
  blank_ids <- all_transcripts[[tma]]$cell_id
  blank_mat <- all_transcripts[[tma]][, grep("BLANK", 
                                                colnames(all_transcripts[[tma]]))]
  blank_counts <- as.data.frame(rowSums(blank_mat))
  blank_counts$cell_id <- blank_ids
  
  # Remove negative controls and convert to cell x gene matrix
  all_transcripts[[tma]][, grep("NegControl", 
                                colnames(all_transcripts[[tma]]), 
                                invert = FALSE)]
  all_transcripts[[tma]][, grep("BLANK", 
                                colnames(all_transcripts[[tma]]), 
                                invert = FALSE)]
  
  all_transcripts[[tma]] <- all_transcripts[[tma]][, grep("NegControl", 
                                                        colnames(all_transcripts[[tma]]), 
                                                        invert = TRUE)]
  all_transcripts[[tma]] <- all_transcripts[[tma]][, grep("BLANK", 
                                                        colnames(all_transcripts[[tma]]), 
                                                        invert = TRUE)]
  keep_cells <- all_transcripts[[tma]]$cell_id
  all_transcripts[[tma]] <- as.data.frame(all_transcripts[[tma]])
  rownames(all_transcripts[[tma]]) <- keep_cells
  all_transcripts[[tma]] <- all_transcripts[[tma]][, -1]
  all_transcripts[[tma]] <- as.matrix(t(all_transcripts[[tma]]))
  
  # Subset nuclear metadata to "cells" with transcripts that overlap nuclei
  updated_metadata[[tma]] <- metadata[[tma]][metadata[[tma]]$cell_id %in% keep_cells, ]
  
  # Add blank counts to metadata
  updated_metadata[[tma]] <- full_join(updated_metadata[[tma]], blank_counts,
                                      by = "cell_id")
  updated_metadata[[tma]] <- updated_metadata[[tma]] %>%
    dplyr::rename(num.blank = `rowSums(blank_mat)`)
  rownames(updated_metadata[[tma]]) <- updated_metadata[[tma]]$cell_id
}

# Nuclear
for (tma in tma_ids) {
  message(paste("Getting cell counts for TMA ", tma))
  
  # Filter out low quality transcripts
  nuc_transcripts[[tma]] <- transcripts[[tma]][transcripts[[tma]]$qv > 20, ]
  
  # Find transcripts that overlap a nucleus
  nuc_transcripts[[tma]] <- nuc_transcripts[[tma]][nuc_transcripts[[tma]]$overlaps_nucleus == 1, ]
  
  # Create cell x gene dataframe
  nuc_transcripts[[tma]] <- as.data.frame(table(nuc_transcripts[[tma]]$cell_id, 
                                               nuc_transcripts[[tma]]$feature_name))
  names(nuc_transcripts[[tma]]) <- c("cell_id", "feature_name", "Count")
  nuc_transcripts[[tma]] <- nuc_transcripts[[tma]] %>% 
    pivot_wider(names_from = "feature_name", values_from = "Count")
  
  # Get blanks count per cell
  blank_ids <- nuc_transcripts[[tma]]$cell_id
  blank_mat <- nuc_transcripts[[tma]][, grep("BLANK", 
                                                colnames(nuc_transcripts[[tma]]))]
  blank_counts <- as.data.frame(rowSums(blank_mat))
  blank_counts$cell_id <- blank_ids
  
  # Remove negative controls and convert to cell x gene matrix
  nuc_transcripts[[tma]][, grep("NegControl", 
                                colnames(nuc_transcripts[[tma]]), 
                                invert = FALSE)]
  nuc_transcripts[[tma]][, grep("BLANK", 
                                colnames(nuc_transcripts[[tma]]), 
                                invert = FALSE)]
  
  nuc_transcripts[[tma]] <- nuc_transcripts[[tma]][, grep("NegControl", 
                                                        colnames(nuc_transcripts[[tma]]), 
                                                        invert = TRUE)]
  nuc_transcripts[[tma]] <- nuc_transcripts[[tma]][, grep("BLANK", 
                                                        colnames(nuc_transcripts[[tma]]), 
                                                        invert = TRUE)]
  keep_cells <- nuc_transcripts[[tma]]$cell_id
  nuc_transcripts[[tma]] <- as.data.frame(nuc_transcripts[[tma]])
  rownames(nuc_transcripts[[tma]]) <- keep_cells
  nuc_transcripts[[tma]] <- nuc_transcripts[[tma]][, -1]
  nuc_transcripts[[tma]] <- as.matrix(t(nuc_transcripts[[tma]]))
  
  # Subset nuclear metadata to "cells" with transcripts that overlap nuclei
  nuc_updated_metadata[[tma]] <- metadata[[tma]][metadata[[tma]]$cell_id %in% keep_cells, ]
  
  # Add blank counts to metadata
  nuc_updated_metadata[[tma]] <- full_join(nuc_updated_metadata[[tma]], blank_counts,
                                      by = "cell_id")
  nuc_updated_metadata[[tma]] <- nuc_updated_metadata[[tma]] %>%
    dplyr::rename(num.blank = `rowSums(blank_mat)`)
  rownames(nuc_updated_metadata[[tma]]) <- nuc_updated_metadata[[tma]]$cell_id
}

```

### Create Seurat objects

```{r, message = F, warning = F, eval = F}

obj_list <- list()
obj_list <- sapply(tma_ids, function(XX) {
  # Create a Seurat object containing the RNA data
  sobj <- CreateSeuratObject(counts = all_transcripts[[XX]], 
                             assay = "RNA")
  
  # Add metadata
  sobj <- AddMetaData(sobj, metadata = updated_metadata[[XX]])
  sobj$TMA <- XX
  
  # Remove cells with 0 nCount_RNA
  sobj <- subset(sobj, subset = nCount_RNA != 0)
  
  # Rename cells to add TMA name as prefix
  sobj <- RenameCells(sobj, add.cell.id = XX)
  
  # Add spatial coordinates as dimension reduction objects
  #position_xy <- cbind(sobj$adj_x_centroid, sobj$adj_y_centroid)
  position_xy <- cbind(sobj$x_centroid, sobj$y_centroid)
  row.names(position_xy) <- row.names(sobj@meta.data)
  colnames(position_xy) <- c("SP_1", "SP_2")
  sobj[["sp"]] <- CreateDimReducObject(embeddings = position_xy, key = "SP_",
                                       assay = DefaultAssay(sobj))
  obj_list[[XX]] <- sobj
})

#saveRDS(obj_list, "/scratch/hnatri/13384_GBMHGG_SPP1_Xenium/obj_list.rds")

# Nuclear only
nuc_obj_list <- list()
nuc_obj_list <- sapply(tma_ids, function(XX) {
  # Create a Seurat object containing the RNA adata
  sobj <- CreateSeuratObject(counts = nuc_transcripts[[XX]], 
                             assay = "RNA")
  
  # Add metadata
  sobj <- AddMetaData(sobj, metadata = nuc_updated_metadata[[XX]])
  sobj$TMA <- XX
  
  # Remove cells with 0 nCount_RNA
  sobj <- subset(sobj, subset = nCount_RNA != 0)
  
  # Rename cells to add TMA name as prefix
  sobj <- RenameCells(sobj, add.cell.id = XX)
  
  # Add spatial coordinates as dimension reduction objects
  #position_xy <- cbind(sobj$adj_x_centroid, sobj$adj_y_centroid)
  position_xy <- cbind(sobj$x_centroid, sobj$y_centroid)
  row.names(position_xy) <- row.names(sobj@meta.data)
  colnames(position_xy) <- c("SP_1", "SP_2")
  sobj[["sp"]] <- CreateDimReducObject(embeddings = position_xy, key = "SP_",
                                       assay = DefaultAssay(sobj))
  nuc_obj_list[[XX]] <- sobj
})

#saveRDS(nuc_obj_list, "/scratch/hnatri/13384_GBMHGG_SPP1_Xenium/nuc_obj_list.rds")

```

### Visualize

```{r, message = F, warning = F, fig.width = 5, fig.height = 8}

obj_list <- readRDS("/scratch/hnatri/13384_GBMHGG_SPP1_Xenium/obj_list.rds")

# Merge objects (cannot do spatial DimPlots for this)
#spatial_unfiltered <- merge(x = obj_list[[1]], y = obj_list[[2]])

#saveRDS(spatial_unfiltered, "/scratch/hnatri/13384_GBMHGG_SPP1_Xenium/spatial_unfiltered.rds")
spatial_unfiltered <- obj_list[["TMA1_0069754"]]

# Add spatial dimension reduction object separately
position_xy <- cbind(spatial_unfiltered$x_centroid,
                     spatial_unfiltered$y_centroid)
row.names(position_xy) <- row.names(spatial_unfiltered@meta.data)
colnames(position_xy) <- c("SP_1", "SP_2")
spatial_unfiltered[["sp"]] <- CreateDimReducObject(
  embeddings = position_xy, key = "SP_", assay = DefaultAssay(spatial_unfiltered))

DimPlot(spatial_unfiltered,
        reduction = "sp",
        group.by = "TMA",
        label = F) +
  coord_fixed() + NoLegend()

#saveRDS(spatial_unfiltered, "/scratch/hnatri/13384_GBMHGG_SPP1_Xenium/spatial_unfiltered.rds")

```

### QC

```{r, message = F, warning = F, fig.width = 4, fig.height = 4}

spatial_unfiltered <- readRDS("/scratch/hnatri/13384_GBMHGG_SPP1_Xenium/spatial_unfiltered.rds")

# Number of cells before filtering
ncol(spatial_unfiltered)

```

```{r, message = F, warning = F, fig.width = 4, fig.height = 4}

# nCount_RNA
spatial_unfiltered@meta.data %>%
  ggplot(aes(x = log(nCount_RNA), fill = TMA)) +
  geom_histogram(bins = 50, show.legend = FALSE, color = "black") +
  theme_classic() +
  theme(title = element_text(color = "black"), 
        axis.text = element_text(color = "black")) +
  facet_wrap(~TMA, scales = "free")

# nucleus_area
spatial_unfiltered@meta.data %>%
  ggplot(aes(x = nucleus_area, fill = TMA)) +
  geom_histogram(bins = 50, show.legend = FALSE, color = "black") +
  theme_classic() +
  theme(title = element_text(color = "black"), 
        axis.text = element_text(color = "black")) +
  facet_wrap(~TMA, scales = "free")

```

```{r, message = F, warning = F, fig.width = 4, fig.height = 4}

spatial_unfiltered <- NormalizeData(spatial_unfiltered)

VlnPlot(spatial_unfiltered,
        features = "nCount_RNA",
        pt.size = 0,
        log = T) +
  theme_classic() +
  NoLegend() +
  ylab("nCount_RNA, log-axis") +
  xlab(unique(spatial_unfiltered$TMA)) +
  theme(axis.text.x = element_blank())

VlnPlot(spatial_unfiltered,
        features = "nFeature_RNA",
        pt.size = 0) +
  theme_classic() +
  NoLegend() +
  ylab("nFeature_RNA") +
  xlab(unique(spatial_unfiltered$TMA)) +
  theme(axis.text.x = element_blank())

VlnPlot(spatial_unfiltered,
        features = "nucleus_area",
        pt.size = 0) +
  theme_classic() +
  NoLegend() +
  ylab("nucleus_area") +
  xlab(unique(spatial_unfiltered$TMA)) +
  theme(axis.text.x = element_blank())

```

```{r, message = F, warning = F, fig.width = 5, fig.height = 5}

# nCount_RNA vs. nFeature_RNA
smoothScatter(log(spatial_unfiltered$nCount_RNA),
              log(spatial_unfiltered$nFeature_RNA),
              cex = 0.5, pch = 16)
abline(v = log(10), h = log(10), lty = "dashed", col = "black")
text(0.3, 4.6, col = "black", adj = c(0, -.1),
     "nCount_RNA >= 10 & nFeature_RNA >= 10")

# nCount RNA vs. nucleus_area
smoothScatter(spatial_unfiltered$nucleus_area,
              log(spatial_unfiltered$nCount_RNA),
              cex = 0.5, pch = 16)
abline(v = c(5, 100), h = log(10), lty = "dashed", col = "black")
text(120, 0.7, col = "black", adj = c(0, -.1),
     "nCount_RNA >= 10 & nucleus_area between 5-100")

# nFeature RNA vs. nucleus_area
smoothScatter(spatial_unfiltered$nucleus_area,
              log(spatial_unfiltered$nFeature_RNA),
              cex = 0.5, pch = 16)
abline(v = c(5, 100), h = log(10), lty = "dashed", col = "black")
text(120, 0.4, col = "black", adj = c(0, -.1),
     "nFeature_RNA >= 10 & & nucleus_area between 5-100")

```

### Filter

```{r, message = F, warning = F, fig.width = 6, fig.height = 4}

# Filter merged and individual data
spatial_filtered <- subset(spatial_unfiltered,
                           subset = nCount_RNA >= 10 & nFeature_RNA >= 10 &
                             #percent.blank <= 5 & 
                             nucleus_area >= 5 & nucleus_area <= 100)

# Number of nuclei before and after filtering
bf_cells <- table(spatial_unfiltered$TMA)
aft_cells <- table(spatial_filtered$TMA)
diff_cells <- bf_cells - aft_cells
prop_kept_cells <- round(aft_cells/bf_cells*100, 2)
prop_kept_cells

# DimPlots before and after filtering
DimPlotCompare("TMA1_0069754")

# Saving the object for clustering with ScanPy
spatial_filtered <- JoinLayers(spatial_filtered)
#saveRDS(merged_spatial, "/scratch/hnatri/13384_GBMHGG_SPP1_Xenium/spatial_filtered.rds")

# Rscript -e "rmarkdown::render('Xenium_processing.Rmd')"
# Then "mv *.html /home/hnatri/13384_GBMHGG_SPP1_Xenium/docs/"

```
